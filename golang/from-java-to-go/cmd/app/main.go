package main

import (
	"fmt"
	"from-java-to-go/internal/structs"
	"from-java-to-go/pkg/utils"
	"sync"
)

func main() {
	// 1. Переменные и типы
	var a int = 10 // Явное объявление
	b := 20        // Короткая форма, вывод типа автоматически
	fmt.Println(a, b)

	// Указатели
	// В Java все объекты — ссылки, а примитивы — нет. В Go все типы могут иметь указатель.
	// Нет null указателя как такового, есть nil.
	p := &a
	fmt.Println(*p) // разыменование
	*p = 15
	fmt.Println(a) // теперь a = 15
	fmt.Println("------------")

	// 2. Коллекции
	// Массивы
	// В Go массивы фиксированной длины, и их размер является частью типа.
	arr := [3]int{1, 2, 3}
	fmt.Println(arr)

	// Slice (аналог List в Java)
	// Работает поверх массива
	slice := []int{1, 2, 3, 4}
	slice = append(slice, 5) // добавление
	fmt.Println(slice)
	fmt.Println("Длина среза:", len(slice))   // длина среза
	fmt.Println("Емкость среза:", cap(slice)) // емкость среза
	// Срезы можно обрезать
	slice = slice[:2]           // срез с 0 по 2 элемент
	fmt.Println(slice)          // [1 2]
	slice = slice[1:]           // срез с 1 элемента до конца
	fmt.Println(slice)          // [2]
	slice = slice[:1]           // срез с 0 по 1 элемент
	fmt.Println(slice)          // [2]
	slice = append(slice, 3, 4) // добавление нескольких элементов
	fmt.Println(slice)          // [2 3 4]

	// Map (аналог HashMap в Java)
	// Ключи могут быть любого сравнимого типа, значения — любого типа.
	// Map и Slice встроены в язык, без импортов
	m := map[string]int{
		"one": 1,
		"two": 2,
	}
	m["three"] = 3   // добавление элемента
	delete(m, "two") // удаление элемента
	fmt.Println(m)
	fmt.Println("------------")

	// 3. Работа с коллекциями
	// Итерации и циклы
	// В Go нет for-each, но есть range, который позволяет итерироваться по срезам, массивам, мапам и строкам.
	slice = []int{10, 20, 30, 40}
	for i, v := range slice {
		fmt.Printf("Индекс: %d, Значение: %d\n", i, v)
	}
	for _, v := range m {
		fmt.Printf("Значение: %d\n", v)
	}
	fmt.Println("------------")

	// 4. Устройство типового проекта. Создание объектов и структуры
	// В Go нет классов, но есть структуры (structs), которые могут содержать
	// поля и методы. Методы могут быть связаны с типами, как в Java.
	// Композиция объектов
	// В Go нет наследования, но есть композиция. Структуры могут включать
	// другие структуры, что позволяет создавать сложные типы.
	car := structs.Car{
		Engine: structs.Engine{Power: 150},
		Model:  "Toyota",
	}
	s := structs.Starter(car) // car реализует интерфейс Starter
	s.Start()
	fmt.Println("------------")

	// 5. Обработка ошибок
	// В Go нет исключений, вместо этого используется множественное возвращаемое значение.
	// Функции могут возвращать значение и ошибку.
	// Приватные функции начинаются с маленькой буквы, публичные — с большой.
	result, err := utils.Divide(10, 2)
	if err != nil {
		fmt.Println("Ошибка:", err)
	} else {
		fmt.Println("Результат деления:", result)
	}
	// Ошибки пробрасываются через return, а не через throw.
	// В Go нет checked exceptions, все ошибки обрабатываются явно.
	// В приложениях ошибку обычно обрабатывают на верхнем уровне мидлвары и тд, а не в каждом методе.
	fmt.Println("------------")

	// 6. Параллельность, горутины, каналы и синхронизация
	// Горутины — легковесные потоки, которые не создают реальные потоки ОС.
	// Используется m*n модель: m горутин на n потоках.
	ch := make(chan string)

	go worker(ch) // запуск горутины
	msg := <-ch   // ожидание
	fmt.Println(msg)

	// Пример с несколькими горутинами
	wg := sync.WaitGroup{}
	for i := 1; i <= 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done() // уменьшаем счетчик по завершении горутины
			fmt.Println("Worker", id)
		}(i)
	}

	wg.Wait() // ждем завершения всех горутин
	fmt.Println("Все горутины завершены")
	fmt.Println("------------")

	mu := sync.Mutex{} // мьютекс для синхронизации доступа к общим данным
	counter := 0
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done() // уменьшаем счетчик по завершении горутины
			mu.Lock()       // блокируем мьютекс
			counter++       // увеличиваем счетчик
			mu.Unlock()     // разблокируем мьютекс
		}()
	}
	wg.Wait() // ждем завершения всех горутин
	fmt.Println("Счетчик:", counter)
	fmt.Println("------------")

	// 7 Работа с внешними библиотеками и интрументами
	// В Go нет Maven или Gradle, но есть go modules.
	// Зависимости управляются через go.mod и go.sum.
	// Для установки зависимостей используется команда `go get`.
	// `go get github.com/golang/mock/gomock`
	// `go vet ./...` проверяет код на наличие ошибок, которые не являются синтаксическими.
	// `go fmt ./...` форматирует код в соответствии с правилами Go.
	// `golangci-lint run` запускает линтеры для проверки кода на ошибки и стили.

	// 8. Тесты
	// В Go тесты пишутся в файлах с суффиксом _test.go.
	// Тесты запускаются с помощью команды `go test`.
	// Все тесты запускаются с помощью команды `go test ./...`
	// Моки в Go обычно создаются вручную или с помощью сторонних библиотек.
	// В Go нет встроенной поддержки моков, но есть библиотеки, которые помогают их создавать.
	// Например, можно использовать библиотеку `gomock` или `testify/mock`
	// `go install github.com/golang/mock/mockgen@latest`
	// `go get github.com/golang/mock/gomock`
	// `export PATH=$PATH:$(go env GOPATH)/bin`
}

func worker(ch chan string) {
	ch <- "Worker: done"
}
